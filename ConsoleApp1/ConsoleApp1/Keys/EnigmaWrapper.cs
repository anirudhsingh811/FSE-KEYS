// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;



namespace EnigmaWrapper
{
    /// <summary>Closure type used to publish processing results.</summary>
    public unsafe partial class CzmAdminITResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal IntPtr args;
            internal IntPtr notify;
            internal IntPtr notifyV2;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmAdminITResult@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr constructor(IntPtr instance, IntPtr zero);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmAdminITResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmAdminITResult>();

        protected bool ownsNativeInstance;

        internal static CzmAdminITResult CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmAdminITResult(native.ToPointer(), skipVTables);
        }

        internal static CzmAdminITResult GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmAdminITResult)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmAdminITResult CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmAdminITResult(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmAdminITResult(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmAdminITResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmAdminITResult()
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmAdminITResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmAdminITResult(CzmAdminITResult result)
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmAdminITResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((CzmAdminITResult.Internal*)Instance) = *((CzmAdminITResult.Internal*)result.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Optional arguments</summary>
        public IntPtr Args
        {
            get
            {
                return ((Internal*)Instance)->args;
            }

            set
            {
                ((Internal*)Instance)->args = (IntPtr)value;
            }
        }

        /// <param name="result">- Passcode validation result</param>
        /// <remarks>Callback function to invoke</remarks>
        public Delegates.Action_IntPtr_EnigmaWrapper_CzmError Notify
        {
            get
            {
                var ptr0 = ((Internal*)Instance)->notify;
                return ptr0 == IntPtr.Zero ? null : (Delegates.Action_IntPtr_EnigmaWrapper_CzmError)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(Delegates.Action_IntPtr_EnigmaWrapper_CzmError));
            }

            set
            {
                ((Internal*)Instance)->notify = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Callback function to invoke</summary>
        /// <param name="result">- Passcode validation result</param>
        /// <param name="creation">- Point in time which passcode was created in seconds since Unix epoch</param>
        public Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long NotifyV2
        {
            get
            {
                var ptr0 = ((Internal*)Instance)->notifyV2;
                return ptr0 == IntPtr.Zero ? null : (Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long));
            }

            set
            {
                ((Internal*)Instance)->notifyV2 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Representation of the IT administrator at customer site.</summary>
    public unsafe partial class CzmAdminIT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal CzmAdminITResult.Internal result;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmAdminIT@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr constructor(IntPtr instance, IntPtr zero);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaAdminITMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaAdminITMakeInstance(IntPtr @return, IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaAdminITValidateDefaultPasscode", CallingConvention = CallingConvention.Cdecl)]
            internal static extern CzmError CzmEnigmaAdminITValidateDefaultPasscode(IntPtr admin, [MarshalAs(UnmanagedType.LPStr)] string serno, [MarshalAs(UnmanagedType.LPStr)] string pass);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmAdminIT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmAdminIT>();

        protected bool ownsNativeInstance;

        internal static CzmAdminIT CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmAdminIT(native.ToPointer(), skipVTables);
        }

        internal static CzmAdminIT GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmAdminIT)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmAdminIT CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmAdminIT(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmAdminIT(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmAdminIT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmAdminIT()
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmAdminIT.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmAdminIT(CzmAdminIT czmAdminIT)
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmAdminIT.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((CzmAdminIT.Internal*)Instance) = *((CzmAdminIT.Internal*)czmAdminIT.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns an initialized instance of #CzmAdminIT</summary>
        /// <param name="result">- closure invoked to publish processing results</param>
        /// <remarks>#CzmAdminIT</remarks>
        public static CzmAdminIT CzmEnigmaAdminITMakeInstance(CzmAdminITResult result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is passed by value.");
            var arg0 = result.Instance;
            var ret = new CzmAdminIT.Internal();
            Internal.CzmEnigmaAdminITMakeInstance(new IntPtr(&ret), arg0);
            return CzmAdminIT.CreateInstance(ret);
        }

        /// <summary>
        /// <para>Validates whether the passcode authenticates the customer's IT administrator domain</para>
        /// <para>of the individual device.</para>
        /// </summary>
        /// <param name="admin">- #CzmAdminIT instance</param>
        /// <param name="serno">- Unique serial number of device to check</param>
        /// <param name="pass">- Passcode</param>
        /// <remarks>
        /// <para>#ENIGMA_NOERROR if validation succeeded, an</para>
        /// <para>error code otherwise</para>
        /// </remarks>
        public static CzmError CzmEnigmaAdminITValidateDefaultPasscode(CzmAdminIT admin, string serno, string pass)
        {
            var arg0 = admin is null ? IntPtr.Zero : admin.Instance;
            var ret = Internal.CzmEnigmaAdminITValidateDefaultPasscode(arg0, serno, pass);
            return ret;
        }

        public CzmAdminITResult Result
        {
            get
            {
                return CzmAdminITResult.CreateInstance(new IntPtr(&((Internal*)Instance)->result));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((Internal*)Instance)->result = *(CzmAdminITResult.Internal*)value.Instance;
            }
        }
    }

    /// <summary>@{</summary>
    public enum CzmError
    {
        /// <summary>Default result code indicating no error.</summary>
        ENIGMA_NOERROR = 0,
        /// <summary>Generic error, unspecified reason.</summary>
        ENIGMA_ERROR = 1,
        /// <summary>An unexpected runtime error occurred.</summary>
        ENIGMA_ERR_RUNTIME_ERROR = 2,
        /// <summary>A function failed to allocate memory.</summary>
        ENIGMA_ERR_OUT_OF_MEMORY = 3,
        /// <summary>The operation is not supported.</summary>
        ENIGMA_ERR_NOT_SUPPORTED = 11,
        /// <summary>One or more arguments are not valid.</summary>
        ENIGMA_ERR_INVALID_ARG = 12,
        /// <summary>The buffer is too small.</summary>
        ENIGMA_ERR_BUFFER_TOO_SMALL = 13,
        /// <summary>The attempt to open the file failed.</summary>
        ENIGMA_ERR_FILE_OPEN_FAILED = 14,
        /// <summary>The attempt to read the file failed.</summary>
        ENIGMA_ERR_FILE_CORRUPT = 15,
        /// <summary>The attempt to open the cryptographic context failed.</summary>
        ENIGMA_ERR_CRYPT_ERROR = 21,
        /// <summary>The attempt to parse the data failed.</summary>
        ENIGMA_ERR_CRYPT_PARSE_ERROR = 22,
        /// <summary>The license key is expired.</summary>
        ENIGMA_ERR_CRYPT_EXPIRED_LICENSE = 23,
        /// <summary>The license key is not valid.</summary>
        ENIGMA_ERR_CRYPT_INVALID_LICENSE = 24,
        ENIGMA_ERR_LAST = 25
    }

    /// <summary>Representation of the trained application specialist at customer site.</summary>
    public unsafe partial class CzmBiomed : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal CzmBiomedResult.Internal result;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmBiomed@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr constructor(IntPtr instance, IntPtr zero);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaBiomedMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaBiomedMakeInstance(IntPtr @return, IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaBiomedValidateDefaultPasscode", CallingConvention = CallingConvention.Cdecl)]
            internal static extern CzmError CzmEnigmaBiomedValidateDefaultPasscode(IntPtr admin, [MarshalAs(UnmanagedType.LPStr)] string serno, [MarshalAs(UnmanagedType.LPStr)] string pass);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmBiomed> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmBiomed>();

        protected bool ownsNativeInstance;

        internal static CzmBiomed CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmBiomed(native.ToPointer(), skipVTables);
        }

        internal static CzmBiomed GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmBiomed)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmBiomed CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmBiomed(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmBiomed(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmBiomed(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmBiomed()
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmBiomed.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmBiomed(CzmBiomed czmBiomed)
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmBiomed.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((CzmBiomed.Internal*)Instance) = *((CzmBiomed.Internal*)czmBiomed.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns an initialized instance of #CzmBiomed</summary>
        /// <param name="result">- closure invoked to publish processing results</param>
        /// <remarks>#CzmBiomed</remarks>
        public static CzmBiomed CzmEnigmaBiomedMakeInstance(CzmBiomedResult result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is passed by value.");
            var arg0 = result.Instance;
            var ret = new CzmBiomed.Internal();
            Internal.CzmEnigmaBiomedMakeInstance(new IntPtr(&ret), arg0);
            return CzmBiomed.CreateInstance(ret);
        }

        /// <summary>
        /// <para>Validates whether the passcode authenticates the customer's application specialists domain</para>
        /// <para>of the individual device.</para>
        /// </summary>
        /// <param name="admin">- #CzmBiomed  instance</param>
        /// <param name="serno">- Unique serial number of device to check</param>
        /// <param name="pass">- Passcode</param>
        /// <remarks>
        /// <para>#ENIGMA_NOERROR if validation succeeded, an</para>
        /// <para>error code otherwise</para>
        /// </remarks>
        public static CzmError CzmEnigmaBiomedValidateDefaultPasscode(CzmBiomed admin, string serno, string pass)
        {
            var arg0 = admin is null ? IntPtr.Zero : admin.Instance;
            var ret = Internal.CzmEnigmaBiomedValidateDefaultPasscode(arg0, serno, pass);
            return ret;
        }

        public CzmBiomedResult Result
        {
            get
            {
                return CzmBiomedResult.CreateInstance(new IntPtr(&((Internal*)Instance)->result));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((Internal*)Instance)->result = *(CzmBiomedResult.Internal*)value.Instance;
            }
        }
    }

    /// <summary>Closure type used to publish processing results.</summary>
    public unsafe partial class CzmBiomedResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal IntPtr args;
            internal IntPtr notify;
            internal IntPtr notifyV2;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmBiomedResult@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr constructor(IntPtr instance, IntPtr zero);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmBiomedResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmBiomedResult>();

        protected bool ownsNativeInstance;

        internal static CzmBiomedResult CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmBiomedResult(native.ToPointer(), skipVTables);
        }

        internal static CzmBiomedResult GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmBiomedResult)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmBiomedResult CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmBiomedResult(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmBiomedResult(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmBiomedResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmBiomedResult()
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmBiomedResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmBiomedResult(CzmBiomedResult czmBiomedResult)
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmBiomedResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((CzmBiomedResult.Internal*)Instance) = *((CzmBiomedResult.Internal*)czmBiomedResult.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Optional arguments</summary>
        public IntPtr Args
        {
            get
            {
                return ((Internal*)Instance)->args;
            }

            set
            {
                ((Internal*)Instance)->args = (IntPtr)value;
            }
        }

        /// <param name="result">- Passcode validation result</param>
        /// <remarks>Callback function to invoke</remarks>
        public Delegates.Action_IntPtr_EnigmaWrapper_CzmError Notify
        {
            get
            {
                var ptr0 = ((Internal*)Instance)->notify;
                return ptr0 == IntPtr.Zero ? null : (Delegates.Action_IntPtr_EnigmaWrapper_CzmError)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(Delegates.Action_IntPtr_EnigmaWrapper_CzmError));
            }

            set
            {
                ((Internal*)Instance)->notify = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Callback function to invoke</summary>
        /// <param name="result">- Passcode validation result</param>
        /// <param name="creation">- Point in time which passcode was created in seconds since Unix epoch</param>
        public Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long NotifyV2
        {
            get
            {
                var ptr0 = ((Internal*)Instance)->notifyV2;
                return ptr0 == IntPtr.Zero ? null : (Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long)Marshal.GetDelegateForFunctionPointer(ptr0, typeof(Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long));
            }

            set
            {
                ((Internal*)Instance)->notifyV2 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class CzmEnigma
    {
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaInit", CallingConvention = CallingConvention.Cdecl)]
            internal static extern CzmError CzmEnigmaInit();

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaDeinit", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaDeinit();
        }

        /// <summary>Initializes the <c>ENIGMA</c> unit with its resources and dependencies.</summary>
        /// <remarks>
        /// <para>Setup must be performed before the <c>ENIGMA</c> unit is used the very</para>
        /// <para>first time.</para>
        /// <para>#ENIGMA_NOERROR if success</para>
        /// <para>#CzmEnigmaDeinit</para>
        /// </remarks>
        public static CzmError CzmEnigmaInit()
        {
            var ret = Internal.CzmEnigmaInit();
            return ret;
        }

        /// <summary>Tears down the <c>ENIGMA</c> unit, relinquishing its resources and dependencies.</summary>
        /// <remarks>
        /// <para>Once this function at the outermost calling stack returns, further use of the</para>
        /// <para> <c>ENIGMA</c> unit results in undefined behavior.</para>
        /// <para>#CzmEnigmaInit</para>
        /// </remarks>
        public static void CzmEnigmaDeinit()
        {
            Internal.CzmEnigmaDeinit();
        }
    }

    /// <summary>Retrieves the version info of the compiled and linked binary artifact.</summary>
    public unsafe partial class CzmVersion : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmVersion@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr constructor(IntPtr instance, IntPtr zero);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetFileVersion", CallingConvention = CallingConvention.Cdecl)]
            internal static extern CzmError CzmEnigmaVersionGetFileVersion(IntPtr info, int* major, int* minor, int* patch, int* build);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetVersion", CallingConvention = CallingConvention.Cdecl)]
            internal static extern CzmError CzmEnigmaVersionGetVersion(IntPtr info, int* major, int* minor, int* patch);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetVersionNumber", CallingConvention = CallingConvention.Cdecl)]
            internal static extern int CzmEnigmaVersionGetVersionNumber(IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetVersionString", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr CzmEnigmaVersionGetVersionString(IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetSourceRev", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr CzmEnigmaVersionGetSourceRev(IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaVersionMakeInstance(IntPtr @return);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmVersion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CzmVersion>();

        protected bool ownsNativeInstance;

        internal static CzmVersion CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmVersion(native.ToPointer(), skipVTables);
        }

        internal static CzmVersion GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmVersion)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmVersion CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmVersion(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmVersion(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmVersion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmVersion()
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmVersion.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmVersion(CzmVersion czmVersion)
        {
            Instance = Marshal.AllocHGlobal(sizeof(CzmVersion.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((CzmVersion.Internal*)Instance) = *((CzmVersion.Internal*)czmVersion.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns the build version of the binary artifact.</summary>
        /// <param name="info">- #CzmVersion instance</param>
        /// <param name="major">- #ENIGMA_VERSION_MAJOR</param>
        /// <param name="minor">- #ENIGMA_VERSION_MINOR</param>
        /// <param name="patch">- #ENIGMA_VERSION_PATCH</param>
        /// <param name="build">- #ENIGMA_VERSION_BUILD</param>
        /// <remarks>#ENIGMA_NOERROR if success, an error code otherwise</remarks>
        public static CzmError CzmEnigmaVersionGetFileVersion(CzmVersion info, ref int major, ref int minor, ref int patch, ref int build)
        {
            var arg0 = info is null ? IntPtr.Zero : info.Instance;
            fixed (int* major1 = &major)
            {
                var arg1 = major1;
                fixed (int* minor2 = &minor)
                {
                    var arg2 = minor2;
                    fixed (int* patch3 = &patch)
                    {
                        var arg3 = patch3;
                        fixed (int* build4 = &build)
                        {
                            var arg4 = build4;
                            var ret = Internal.CzmEnigmaVersionGetFileVersion(arg0, arg1, arg2, arg3, arg4);
                            return ret;
                        }
                    }
                }
            }
        }

        /// <summary>Returns the product version of the binary artifact.</summary>
        /// <param name="info">- #CzmVersion instance</param>
        /// <param name="major">- #ENIGMA_VERSION_MAJOR</param>
        /// <param name="minor">- #ENIGMA_VERSION_MINOR</param>
        /// <param name="patch">- #ENIGMA_VERSION_PATCH</param>
        /// <remarks>#ENIGMA_NOERROR if success, an error code otherwise</remarks>
        public static CzmError CzmEnigmaVersionGetVersion(CzmVersion info, ref int major, ref int minor, ref int patch)
        {
            var arg0 = info is null ? IntPtr.Zero : info.Instance;
            fixed (int* major1 = &major)
            {
                var arg1 = major1;
                fixed (int* minor2 = &minor)
                {
                    var arg2 = minor2;
                    fixed (int* patch3 = &patch)
                    {
                        var arg3 = patch3;
                        var ret = Internal.CzmEnigmaVersionGetVersion(arg0, arg1, arg2, arg3);
                        return ret;
                    }
                }
            }
        }

        /// <summary>Returns the product version of the binary artifact.</summary>
        /// <remarks>#ENIGMA_VERSION_NUMBER</remarks>
        public static int CzmEnigmaVersionGetVersionNumber(CzmVersion info)
        {
            var arg0 = info is null ? IntPtr.Zero : info.Instance;
            var ret = Internal.CzmEnigmaVersionGetVersionNumber(arg0);
            return ret;
        }

        /// <summary>Returns a human-readable string representing the product version of the binary artifact.</summary>
        public static string CzmEnigmaVersionGetVersionString(CzmVersion info)
        {
            var arg0 = info is null ? IntPtr.Zero : info.Instance;
            var ret = Internal.CzmEnigmaVersionGetVersionString(arg0);
            return Marshal.PtrToStringAuto(ret);
        }

        /// <summary>Returns a human-readable string representing the source revision the binary artifact is built from.</summary>
        public static string CzmEnigmaVersionGetSourceRev(CzmVersion info)
        {
            var arg0 = info is null ? IntPtr.Zero : info.Instance;
            var ret = Internal.CzmEnigmaVersionGetSourceRev(arg0);
            return Marshal.PtrToStringAuto(ret);
        }

        /// <summary>Returns an initialized instance of #CzmVersion</summary>
        /// <remarks>#CzmVersion</remarks>
        public static CzmVersion CzmEnigmaVersionMakeInstance
        {
            get
            {
                var ret = new CzmVersion.Internal();
                Internal.CzmEnigmaVersionMakeInstance(new IntPtr(&ret));
                return CzmVersion.CreateInstance(ret);
            }
        }
    }



    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError(IntPtr self, CzmError result);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError_long(IntPtr self, CzmError result, long creation);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError_long_long(IntPtr self, CzmError result, long creation, long expiration);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError_IntPtr_ulong_long_long(IntPtr self, CzmError result, IntPtr user, ulong userLen, long creation, long expiration);

        public class Response
        {
            public  void Action_IntPtr_EnigmaWrapper_CzmError(IntPtr self, CzmError result)
            {

            }

            public  void Action_IntPtr_EnigmaWrapper_CzmError_long(IntPtr self, CzmError result, long creation)
            {

            }

            public  void Action_IntPtr_EnigmaWrapper_CzmError_long_long(IntPtr self, CzmError result, long creation, long expiration)
            {

            }

            public  void Action_IntPtr_EnigmaWrapper_CzmError_IntPtr_ulong_long_long(IntPtr self, CzmError result, IntPtr user, ulong userLen, long creation, long expiration)
            {

            }
        }
    }
}
