// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;



namespace EnigmaWrapper
{
    /// <summary>Closure type used to publish processing results.</summary>
    public unsafe partial class CzmAdminITResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal IntPtr args;
            internal IntPtr notify;
            internal IntPtr notify_V2;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmAdminITResult@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmAdminITResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmAdminITResult>();

        protected bool ownsNativeInstance;

        internal static CzmAdminITResult CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmAdminITResult(native.ToPointer(), skipVTables);
        }

        internal static CzmAdminITResult GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmAdminITResult)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmAdminITResult CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmAdminITResult(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmAdminITResult(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmAdminITResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmAdminITResult()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmAdminITResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmAdminITResult(global::EnigmaWrapper.CzmAdminITResult _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmAdminITResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmAdminITResult.Internal*)Instance) = *((global::EnigmaWrapper.CzmAdminITResult.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Optional arguments</summary>
        public IntPtr Args
        {
            get
            {
                return ((Internal*)Instance)->args;
            }

            set
            {
                ((Internal*)Instance)->args = (IntPtr)value;
            }
        }

        /// <param name="result">- Passcode validation result</param>
        /// <remarks>Callback function to invoke</remarks>
        public global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError Notify
        {
            get
            {
                var __ptr0 = ((Internal*)Instance)->notify;
                return __ptr0 == IntPtr.Zero ? null : (global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError));
            }

            set
            {
                ((Internal*)Instance)->notify = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Callback function to invoke</summary>
        /// <param name="result">- Passcode validation result</param>
        /// <param name="creation">- Point in time which passcode was created in seconds since Unix epoch</param>
        public global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long NotifyV2
        {
            get
            {
                var __ptr0 = ((Internal*)Instance)->notify_V2;
                return __ptr0 == IntPtr.Zero ? null : (global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long));
            }

            set
            {
                ((Internal*)Instance)->notify_V2 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Representation of the IT administrator at customer site.</summary>
    public unsafe partial class CzmAdminIT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal global::EnigmaWrapper.CzmAdminITResult.Internal result;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmAdminIT@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaAdminITMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaAdminITMakeInstance(IntPtr @return, IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaAdminITValidateDefaultPasscode", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaAdminITValidateDefaultPasscode(IntPtr admin, [MarshalAs(UnmanagedType.LPStr)] string serno, [MarshalAs(UnmanagedType.LPStr)] string pass);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmAdminIT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmAdminIT>();

        protected bool ownsNativeInstance;

        internal static CzmAdminIT CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmAdminIT(native.ToPointer(), skipVTables);
        }

        internal static CzmAdminIT GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmAdminIT)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmAdminIT CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmAdminIT(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmAdminIT(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmAdminIT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmAdminIT()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmAdminIT.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmAdminIT(global::EnigmaWrapper.CzmAdminIT _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmAdminIT.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmAdminIT.Internal*)Instance) = *((global::EnigmaWrapper.CzmAdminIT.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns an initialized instance of #CzmAdminIT</summary>
        /// <param name="result">- closure invoked to publish processing results</param>
        /// <remarks>#CzmAdminIT</remarks>
        public static global::EnigmaWrapper.CzmAdminIT CzmEnigmaAdminITMakeInstance(global::EnigmaWrapper.CzmAdminITResult result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is passed by value.");
            var __arg0 = result.Instance;
            var __ret = new global::EnigmaWrapper.CzmAdminIT.Internal();
            Internal.CzmEnigmaAdminITMakeInstance(new IntPtr(&__ret), __arg0);
            return global::EnigmaWrapper.CzmAdminIT.CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Validates whether the passcode authenticates the customer's IT administrator domain</para>
        /// <para>of the individual device.</para>
        /// </summary>
        /// <param name="admin">- #CzmAdminIT instance</param>
        /// <param name="serno">- Unique serial number of device to check</param>
        /// <param name="pass">- Passcode</param>
        /// <remarks>
        /// <para>#ENIGMA_NOERROR if validation succeeded, an</para>
        /// <para>error code otherwise</para>
        /// </remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaAdminITValidateDefaultPasscode(global::EnigmaWrapper.CzmAdminIT admin, string serno, string pass)
        {
            var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
            var __ret = Internal.CzmEnigmaAdminITValidateDefaultPasscode(__arg0, serno, pass);
            return __ret;
        }

        public global::EnigmaWrapper.CzmAdminITResult Result
        {
            get
            {
                return global::EnigmaWrapper.CzmAdminITResult.CreateInstance(new IntPtr(&((Internal*)Instance)->result));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((Internal*)Instance)->result = *(global::EnigmaWrapper.CzmAdminITResult.Internal*)value.Instance;
            }
        }
    }

    /// <summary>@{</summary>
    public enum CzmError
    {
        /// <summary>Default result code indicating no error.</summary>
        ENIGMA_NOERROR = 0,
        /// <summary>Generic error, unspecified reason.</summary>
        ENIGMA_ERROR = 1,
        /// <summary>An unexpected runtime error occurred.</summary>
        ENIGMA_ERR_RUNTIME_ERROR = 2,
        /// <summary>A function failed to allocate memory.</summary>
        ENIGMA_ERR_OUT_OF_MEMORY = 3,
        /// <summary>The operation is not supported.</summary>
        ENIGMA_ERR_NOT_SUPPORTED = 11,
        /// <summary>One or more arguments are not valid.</summary>
        ENIGMA_ERR_INVALID_ARG = 12,
        /// <summary>The buffer is too small.</summary>
        ENIGMA_ERR_BUFFER_TOO_SMALL = 13,
        /// <summary>The attempt to open the file failed.</summary>
        ENIGMA_ERR_FILE_OPEN_FAILED = 14,
        /// <summary>The attempt to read the file failed.</summary>
        ENIGMA_ERR_FILE_CORRUPT = 15,
        /// <summary>The attempt to open the cryptographic context failed.</summary>
        ENIGMA_ERR_CRYPT_ERROR = 21,
        /// <summary>The attempt to parse the data failed.</summary>
        ENIGMA_ERR_CRYPT_PARSE_ERROR = 22,
        /// <summary>The license key is expired.</summary>
        ENIGMA_ERR_CRYPT_EXPIRED_LICENSE = 23,
        /// <summary>The license key is not valid.</summary>
        ENIGMA_ERR_CRYPT_INVALID_LICENSE = 24,
        ENIGMA_ERR_LAST = 25
    }


    /// <summary>Representation of the trained application specialist at customer site.</summary>
    public unsafe partial class CzmBiomed : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal global::EnigmaWrapper.CzmBiomedResult.Internal result;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmBiomed@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaBiomedMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaBiomedMakeInstance(IntPtr @return, IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaBiomedValidateDefaultPasscode", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaBiomedValidateDefaultPasscode(IntPtr admin, [MarshalAs(UnmanagedType.LPStr)] string serno, [MarshalAs(UnmanagedType.LPStr)] string pass);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmBiomed> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmBiomed>();

        protected bool ownsNativeInstance;

        internal static CzmBiomed CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmBiomed(native.ToPointer(), skipVTables);
        }

        internal static CzmBiomed GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmBiomed)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmBiomed CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmBiomed(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmBiomed(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmBiomed(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmBiomed()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmBiomed.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmBiomed(global::EnigmaWrapper.CzmBiomed _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmBiomed.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmBiomed.Internal*)Instance) = *((global::EnigmaWrapper.CzmBiomed.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns an initialized instance of #CzmBiomed</summary>
        /// <param name="result">- closure invoked to publish processing results</param>
        /// <remarks>#CzmBiomed</remarks>
        public static global::EnigmaWrapper.CzmBiomed CzmEnigmaBiomedMakeInstance(global::EnigmaWrapper.CzmBiomedResult result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is passed by value.");
            var __arg0 = result.Instance;
            var __ret = new global::EnigmaWrapper.CzmBiomed.Internal();
            Internal.CzmEnigmaBiomedMakeInstance(new IntPtr(&__ret), __arg0);
            return global::EnigmaWrapper.CzmBiomed.CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Validates whether the passcode authenticates the customer's application specialists domain</para>
        /// <para>of the individual device.</para>
        /// </summary>
        /// <param name="admin">- #CzmBiomed  instance</param>
        /// <param name="serno">- Unique serial number of device to check</param>
        /// <param name="pass">- Passcode</param>
        /// <remarks>
        /// <para>#ENIGMA_NOERROR if validation succeeded, an</para>
        /// <para>error code otherwise</para>
        /// </remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaBiomedValidateDefaultPasscode(global::EnigmaWrapper.CzmBiomed admin, string serno, string pass)
        {
            var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
            var __ret = Internal.CzmEnigmaBiomedValidateDefaultPasscode(__arg0, serno, pass);
            return __ret;
        }

        public global::EnigmaWrapper.CzmBiomedResult Result
        {
            get
            {
                return global::EnigmaWrapper.CzmBiomedResult.CreateInstance(new IntPtr(&((Internal*)Instance)->result));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((Internal*)Instance)->result = *(global::EnigmaWrapper.CzmBiomedResult.Internal*)value.Instance;
            }
        }
    }

    /// <summary>Closure type used to publish processing results.</summary>
    public unsafe partial class CzmBiomedResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal IntPtr args;
            internal IntPtr notify;
            internal IntPtr notify_V2;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmBiomedResult@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmBiomedResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmBiomedResult>();

        protected bool ownsNativeInstance;

        internal static CzmBiomedResult CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmBiomedResult(native.ToPointer(), skipVTables);
        }

        internal static CzmBiomedResult GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmBiomedResult)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmBiomedResult CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmBiomedResult(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmBiomedResult(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmBiomedResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmBiomedResult()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmBiomedResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmBiomedResult(global::EnigmaWrapper.CzmBiomedResult _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmBiomedResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmBiomedResult.Internal*)Instance) = *((global::EnigmaWrapper.CzmBiomedResult.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Optional arguments</summary>
        public IntPtr Args
        {
            get
            {
                return ((Internal*)Instance)->args;
            }

            set
            {
                ((Internal*)Instance)->args = (IntPtr)value;
            }
        }

        /// <param name="result">- Passcode validation result</param>
        /// <remarks>Callback function to invoke</remarks>
        public global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError Notify
        {
            get
            {
                var __ptr0 = ((Internal*)Instance)->notify;
                return __ptr0 == IntPtr.Zero ? null : (global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError));
            }

            set
            {
                ((Internal*)Instance)->notify = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Callback function to invoke</summary>
        /// <param name="result">- Passcode validation result</param>
        /// <param name="creation">- Point in time which passcode was created in seconds since Unix epoch</param>
        public global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long NotifyV2
        {
            get
            {
                var __ptr0 = ((Internal*)Instance)->notify_V2;
                return __ptr0 == IntPtr.Zero ? null : (global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long));
            }

            set
            {
                ((Internal*)Instance)->notify_V2 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class CzmEnigma
    {
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaInit", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaInit();

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaDeinit", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaDeinit();
        }

        /// <summary>Initializes the <c>ENIGMA</c> unit with its resources and dependencies.</summary>
        /// <remarks>
        /// <para>Setup must be performed before the <c>ENIGMA</c> unit is used the very</para>
        /// <para>first time.</para>
        /// <para>#ENIGMA_NOERROR if success</para>
        /// <para>#CzmEnigmaDeinit</para>
        /// </remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaInit()
        {
            var __ret = Internal.CzmEnigmaInit();
            return __ret;
        }

        /// <summary>Tears down the <c>ENIGMA</c> unit, relinquishing its resources and dependencies.</summary>
        /// <remarks>
        /// <para>Once this function at the outermost calling stack returns, further use of the</para>
        /// <para> <c>ENIGMA</c> unit results in undefined behavior.</para>
        /// <para>#CzmEnigmaInit</para>
        /// </remarks>
        public static void CzmEnigmaDeinit()
        {
            Internal.CzmEnigmaDeinit();
        }
    }

    /// <summary>Retrieves the version info of the compiled and linked binary artifact.</summary>
    public unsafe partial class CzmVersion : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmVersion@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetFileVersion", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaVersionGetFileVersion(IntPtr info, int* major, int* minor, int* patch, int* build);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetVersion", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaVersionGetVersion(IntPtr info, int* major, int* minor, int* patch);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetVersionNumber", CallingConvention = CallingConvention.Cdecl)]
            internal static extern int CzmEnigmaVersionGetVersionNumber(IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetVersionString", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr CzmEnigmaVersionGetVersionString(IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionGetSourceRev", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr CzmEnigmaVersionGetSourceRev(IntPtr info);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaVersionMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaVersionMakeInstance(IntPtr @return);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmVersion> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmVersion>();

        protected bool ownsNativeInstance;

        internal static CzmVersion CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmVersion(native.ToPointer(), skipVTables);
        }

        internal static CzmVersion GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmVersion)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmVersion CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmVersion(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmVersion(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmVersion(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmVersion()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmVersion.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmVersion(global::EnigmaWrapper.CzmVersion _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmVersion.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmVersion.Internal*)Instance) = *((global::EnigmaWrapper.CzmVersion.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns the build version of the binary artifact.</summary>
        /// <param name="info">- #CzmVersion instance</param>
        /// <param name="major">- #ENIGMA_VERSION_MAJOR</param>
        /// <param name="minor">- #ENIGMA_VERSION_MINOR</param>
        /// <param name="patch">- #ENIGMA_VERSION_PATCH</param>
        /// <param name="build">- #ENIGMA_VERSION_BUILD</param>
        /// <remarks>#ENIGMA_NOERROR if success, an error code otherwise</remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaVersionGetFileVersion(global::EnigmaWrapper.CzmVersion info, ref int major, ref int minor, ref int patch, ref int build)
        {
            var __arg0 = info is null ? IntPtr.Zero : info.Instance;
            fixed (int* __major1 = &major)
            {
                var __arg1 = __major1;
                fixed (int* __minor2 = &minor)
                {
                    var __arg2 = __minor2;
                    fixed (int* __patch3 = &patch)
                    {
                        var __arg3 = __patch3;
                        fixed (int* __build4 = &build)
                        {
                            var __arg4 = __build4;
                            var __ret = Internal.CzmEnigmaVersionGetFileVersion(__arg0, __arg1, __arg2, __arg3, __arg4);
                            return __ret;
                        }
                    }
                }
            }
        }

        /// <summary>Returns the product version of the binary artifact.</summary>
        /// <param name="info">- #CzmVersion instance</param>
        /// <param name="major">- #ENIGMA_VERSION_MAJOR</param>
        /// <param name="minor">- #ENIGMA_VERSION_MINOR</param>
        /// <param name="patch">- #ENIGMA_VERSION_PATCH</param>
        /// <remarks>#ENIGMA_NOERROR if success, an error code otherwise</remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaVersionGetVersion(global::EnigmaWrapper.CzmVersion info, ref int major, ref int minor, ref int patch)
        {
            var __arg0 = info is null ? IntPtr.Zero : info.Instance;
            fixed (int* __major1 = &major)
            {
                var __arg1 = __major1;
                fixed (int* __minor2 = &minor)
                {
                    var __arg2 = __minor2;
                    fixed (int* __patch3 = &patch)
                    {
                        var __arg3 = __patch3;
                        var __ret = Internal.CzmEnigmaVersionGetVersion(__arg0, __arg1, __arg2, __arg3);
                        return __ret;
                    }
                }
            }
        }

        /// <summary>Returns the product version of the binary artifact.</summary>
        /// <remarks>#ENIGMA_VERSION_NUMBER</remarks>
        public static int CzmEnigmaVersionGetVersionNumber(global::EnigmaWrapper.CzmVersion info)
        {
            var __arg0 = info is null ? IntPtr.Zero : info.Instance;
            var __ret = Internal.CzmEnigmaVersionGetVersionNumber(__arg0);
            return __ret;
        }

        /// <summary>Returns a human-readable string representing the product version of the binary artifact.</summary>
        public static string CzmEnigmaVersionGetVersionString(global::EnigmaWrapper.CzmVersion info)
        {
            var __arg0 = info is null ? IntPtr.Zero : info.Instance;
            var __ret = Internal.CzmEnigmaVersionGetVersionString(__arg0);
            return Marshal.PtrToStringAuto(__ret);
        }

        /// <summary>Returns a human-readable string representing the source revision the binary artifact is built from.</summary>
        public static string CzmEnigmaVersionGetSourceRev(global::EnigmaWrapper.CzmVersion info)
        {
            var __arg0 = info is null ? IntPtr.Zero : info.Instance;
            var __ret = Internal.CzmEnigmaVersionGetSourceRev(__arg0);
            return Marshal.PtrToStringAuto(__ret);
        }

        /// <summary>Returns an initialized instance of #CzmVersion</summary>
        /// <remarks>#CzmVersion</remarks>
        public static global::EnigmaWrapper.CzmVersion CzmEnigmaVersionMakeInstance
        {
            get
            {
                var __ret = new global::EnigmaWrapper.CzmVersion.Internal();
                Internal.CzmEnigmaVersionMakeInstance(new IntPtr(&__ret));
                return global::EnigmaWrapper.CzmVersion.CreateInstance(__ret);
            }
        }
    }

    /// <summary>Closure type used to publish processing results.</summary>
    public unsafe partial class CzmFactoryResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal IntPtr args;
            internal IntPtr notify;
            internal IntPtr notify_V2;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmFactoryResult@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmFactoryResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmFactoryResult>();

        protected bool ownsNativeInstance;

        internal static CzmFactoryResult CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmFactoryResult(native.ToPointer(), skipVTables);
        }

        internal static CzmFactoryResult GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmFactoryResult)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmFactoryResult CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmFactoryResult(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmFactoryResult(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmFactoryResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmFactoryResult()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmFactoryResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmFactoryResult(global::EnigmaWrapper.CzmFactoryResult _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmFactoryResult.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmFactoryResult.Internal*)Instance) = *((global::EnigmaWrapper.CzmFactoryResult.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Optional arguments</summary>
        public IntPtr Args
        {
            get
            {
                return ((Internal*)Instance)->args;
            }

            set
            {
                ((Internal*)Instance)->args = (IntPtr)value;
            }
        }

        /// <param name="result">- Passcode validation result</param>
        /// <remarks>Callback function to invoke</remarks>
        public global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError Notify
        {
            get
            {
                var __ptr0 = ((Internal*)Instance)->notify;
                return __ptr0 == IntPtr.Zero ? null : (global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError));
            }

            set
            {
                ((Internal*)Instance)->notify = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Callback function to invoke</summary>
        /// <param name="result">- Passcode validation result</param>
        /// <param name="creation">- Point in time which passcode was created in seconds since Unix epoch</param>
        public global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long_long NotifyV2
        {
            get
            {
                var __ptr0 = ((Internal*)Instance)->notify_V2;
                return __ptr0 == IntPtr.Zero ? null : (global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long_long)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::EnigmaWrapper.Delegates.Action_IntPtr_EnigmaWrapper_CzmError_long_long));
            }

            set
            {
                ((Internal*)Instance)->notify_V2 = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>Representation of the in-house technicians within the assembly line.</summary>
    public unsafe partial class CzmFactory : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct Internal
        {
            internal global::EnigmaWrapper.CzmFactoryResult.Internal result;

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmFactory@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
            internal static extern IntPtr cctor(IntPtr instance, IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaFactoryMakeInstance", CallingConvention = CallingConvention.Cdecl)]
            internal static extern void CzmEnigmaFactoryMakeInstance(IntPtr @return, IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaFactoryValidatePasscode", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaFactoryValidatePasscode(IntPtr admin, long today, [MarshalAs(UnmanagedType.LPArray)] string[] prod, ulong prodCnt, [MarshalAs(UnmanagedType.LPStr)] string pass);

            [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaFactoryValidatePasscodeFromFile", CallingConvention = CallingConvention.Cdecl)]
            internal static extern global::EnigmaWrapper.CzmError CzmEnigmaFactoryValidatePasscodeFromFile(IntPtr admin, long today, [MarshalAs(UnmanagedType.LPArray)] string[] prod, ulong prodCnt, IntPtr root, ulong rootLen);
        }

        public IntPtr Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmFactory> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmFactory>();

        protected bool ownsNativeInstance;

        internal static CzmFactory CreateInstance(IntPtr native, bool skipVTables = false)
        {
            return new CzmFactory(native.ToPointer(), skipVTables);
        }

        internal static CzmFactory GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (CzmFactory)managed;
            var result = CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static CzmFactory CreateInstance(Internal native, bool skipVTables = false)
        {
            return new CzmFactory(native, skipVTables);
        }

        private static void* CopyValue(Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(Internal));
            *(Internal*)ret = native;
            return ret.ToPointer();
        }

        private CzmFactory(Internal native, bool skipVTables = false)
            : this(CopyValue(native), skipVTables)
        {
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        protected CzmFactory(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            Instance = new IntPtr(native);
        }

        public CzmFactory()
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmFactory.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
        }

        public CzmFactory(global::EnigmaWrapper.CzmFactory _0)
        {
            Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmFactory.Internal));
            ownsNativeInstance = true;
            NativeToManagedMap[Instance] = this;
            *((global::EnigmaWrapper.CzmFactory.Internal*)Instance) = *((global::EnigmaWrapper.CzmFactory.Internal*)_0.Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
        {
            if (Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(Instance, out _);
            DisposePartial(disposing);
            if (ownsNativeInstance)
                Marshal.FreeHGlobal(Instance);
            Instance = IntPtr.Zero;
        }

        /// <summary>Returns an initialized instance of #CzmFactory</summary>
        /// <param name="result">- closure invoked to publish processing results</param>
        /// <remarks>#CzmFactory</remarks>
        public static global::EnigmaWrapper.CzmFactory CzmEnigmaFactoryMakeInstance(global::EnigmaWrapper.CzmFactoryResult result)
        {
            if (ReferenceEquals(result, null))
                throw new global::System.ArgumentNullException("result", "Cannot be null because it is passed by value.");
            var __arg0 = result.Instance;
            var __ret = new global::EnigmaWrapper.CzmFactory.Internal();
            Internal.CzmEnigmaFactoryMakeInstance(new IntPtr(&__ret), __arg0);
            return global::EnigmaWrapper.CzmFactory.CreateInstance(__ret);
        }

        /// <summary>
        /// <para>Validates whether the passcode authenticates the in-house technician domain for at least</para>
        /// <para>one product specified.</para>
        /// </summary>
        /// <param name="admin">- #CzmFactory instance</param>
        /// <param name="today">- Current calendar date in seconds since UTC 01-JAN-1970 00:00:00</param>
        /// <param name="prod">- Product codes to check</param>
        /// <param name="pass">- Passcode</param>
        /// <remarks>
        /// <para>Authentication is granted for the defined range of consecutive calendar days.</para>
        /// <para>#ENIGMA_NOERROR if validation succeeded for at least one product</para>
        /// <para>code in</para>
        /// </remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaFactoryValidatePasscode(global::EnigmaWrapper.CzmFactory admin, long today, string[] prod, ulong prodCnt, string pass)
        {
            var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
            var __ret = Internal.CzmEnigmaFactoryValidatePasscode(__arg0, today, prod, prodCnt, pass);
            return __ret;
        }

        /// <summary>
        /// <para>Validates whether the passcode stored in a keyfile authenticates the in-house</para>
        /// <para>technician domain for at least one product specified.</para>
        /// </summary>
        /// <param name="admin">- #CzmFactory instance</param>
        /// <param name="today">- Current calendar date in seconds since UTC 01-JAN-1970 00:00:00</param>
        /// <param name="prod">- Product codes to check</param>
        /// <param name="root">- UTF16-encoded path to file storage loading the keyfile from</param>
        /// <remarks>
        /// <para>Authentication is granted for the defined range of consecutive calendar days.</para>
        /// <para>#ENIGMA_NOERROR if validation succeeded for at least one product</para>
        /// <para>code in</para>
        /// </remarks>
        public static global::EnigmaWrapper.CzmError CzmEnigmaFactoryValidatePasscodeFromFile(global::EnigmaWrapper.CzmFactory admin, long today, string[] prod, ulong prodCnt, IntPtr root, ulong rootLen)
        {
            var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
            var __ret = Internal.CzmEnigmaFactoryValidatePasscodeFromFile(__arg0, today, prod, prodCnt, root, rootLen);
            return __ret;
        }

        public global::EnigmaWrapper.CzmFactoryResult Result
        {
            get
            {
                return global::EnigmaWrapper.CzmFactoryResult.CreateInstance(new IntPtr(&((Internal*)Instance)->result));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((Internal*)Instance)->result = *(global::EnigmaWrapper.CzmFactoryResult.Internal*)value.Instance;
            }
        }
    }

    

    /// <summary>Representation of the field service engineer.</summary>
    //public unsafe partial class CzmService : IDisposable
    //{
    //    [StructLayout(LayoutKind.Sequential, Size = 16)]
    //    public partial struct Internal
    //    {
    //        internal global::EnigmaWrapper.CzmServiceResult.Internal result;

    //        [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "??0CzmService@@QEAA@AEBU0@@Z", CallingConvention = CallingConvention.Cdecl)]
    //        internal static extern IntPtr Cctor(IntPtr instance, IntPtr _0);

    //        [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaServiceMakeInstance", CallingConvention = CallingConvention.Cdecl)]
    //        internal static extern void CzmEnigmaServiceMakeInstance(IntPtr @return, IntPtr result);

    //        [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaServiceValidateOnedayPasscode", CallingConvention = CallingConvention.Cdecl)]
    //        internal static extern global::EnigmaWrapper.CzmError CzmEnigmaServiceValidateOnedayPasscode(IntPtr admin, long today, IntPtr user, ulong userLen, [MarshalAs(UnmanagedType.LPArray)] string[] prod, ulong prodCnt, [MarshalAs(UnmanagedType.LPStr)] string pass);

    //        [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaServiceValidateOnedayPasscodeFromFile", CallingConvention = CallingConvention.Cdecl)]
    //        internal static extern global::EnigmaWrapper.CzmError CzmEnigmaServiceValidateOnedayPasscodeFromFile(IntPtr admin, long today, IntPtr user, ulong userLen, [MarshalAs(UnmanagedType.LPArray)] string[] prod, ulong prodCnt, IntPtr root, ulong rootLen);

    //        [SuppressUnmanagedCodeSecurity, DllImport(@"C:\Users\Customer\Downloads\FSE\Czm_Enigma_2.0.0\build\native\bin\x64\v141\Debug\Enigma.dll", EntryPoint = "CzmEnigmaServiceValidateMasterPasscodeFromFile", CallingConvention = CallingConvention.Cdecl)]
    //        internal static extern global::EnigmaWrapper.CzmError CzmEnigmaServiceValidateMasterPasscodeFromFile(IntPtr admin, long today, [MarshalAs(UnmanagedType.LPArray)] string[] prod, ulong prodCnt, IntPtr root, ulong rootLen);
    //    }

    //    public IntPtr Instance { get; protected set; }

    //    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmService> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EnigmaWrapper.CzmService>();

    //    protected bool ownsNativeInstance;

    //    internal static CzmService CreateInstance(IntPtr native, bool skipVTables = false)
    //    {
    //        return new CzmService(native.ToPointer(), skipVTables);
    //    }

    //    internal static CzmService GetOrCreateInstance(IntPtr native, bool saveInstance = false, bool skipVTables = false)
    //    {
    //        if (native == IntPtr.Zero)
    //            return null;
    //        if (NativeToManagedMap.TryGetValue(native, out var managed))
    //            return (CzmService)managed;
    //        var result = CreateInstance(native, skipVTables);
    //        if (saveInstance)
    //            NativeToManagedMap[native] = result;
    //        return result;
    //    }

    //    internal static CzmService CreateInstance(Internal native, bool skipVTables = false)
    //    {
    //        return new CzmService(native, skipVTables);
    //    }

    //    private static void* CopyValue(Internal native)
    //    {
    //        var ret = Marshal.AllocHGlobal(sizeof(Internal));
    //        *(Internal*)ret = native;
    //        return ret.ToPointer();
    //    }

    //    private CzmService(Internal native, bool skipVTables = false)
    //        : this(CopyValue(native), skipVTables)
    //    {
    //        ownsNativeInstance = true;
    //        NativeToManagedMap[Instance] = this;
    //    }

    //    protected CzmService(void* native, bool skipVTables = false)
    //    {
    //        if (native == null)
    //            return;
    //        Instance = new IntPtr(native);
    //    }

    //    public CzmService()
    //    {
    //        Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmService.Internal));
    //        ownsNativeInstance = true;
    //        NativeToManagedMap[Instance] = this;
    //    }

    //    public CzmService(global::EnigmaWrapper.CzmService _0)
    //    {
    //        Instance = Marshal.AllocHGlobal(sizeof(global::EnigmaWrapper.CzmService.Internal));
    //        ownsNativeInstance = true;
    //        NativeToManagedMap[Instance] = this;
    //        *((global::EnigmaWrapper.CzmService.Internal*)Instance) = *((global::EnigmaWrapper.CzmService.Internal*)_0.Instance);
    //    }

    //    public void Dispose()
    //    {
    //        Dispose(disposing: true, callNativeDtor: ownsNativeInstance);
    //    }

    //    partial void DisposePartial(bool disposing);

    //    internal protected virtual void Dispose(bool disposing, bool callNativeDtor)
    //    {
    //        if (Instance == IntPtr.Zero)
    //            return;
    //        NativeToManagedMap.TryRemove(Instance, out _);
    //        DisposePartial(disposing);
    //        if (ownsNativeInstance)
    //            Marshal.FreeHGlobal(Instance);
    //        Instance = IntPtr.Zero;
    //    }

    //    /// <summary>Returns an initialized instance of #CzmService</summary>
    //    /// <param name="result">- closure invoked to publish processing results</param>
    //    /// <remarks>#CzmService</remarks>
    //    public static global::EnigmaWrapper.CzmService CzmEnigmaServiceMakeInstance(global::EnigmaWrapper.CzmServiceResult result)
    //    {
    //        if (ReferenceEquals(result, null))
    //            throw new global::System.ArgumentNullException("result", "Cannot be null because it is passed by value.");
    //        var __arg0 = result.Instance;
    //        var __ret = new global::EnigmaWrapper.CzmService.Internal();
    //        Internal.CzmEnigmaServiceMakeInstance(new IntPtr(&__ret), __arg0);
    //        return global::EnigmaWrapper.CzmService.CreateInstance(__ret);
    //    }

    //    /// <summary>
    //    /// <para>Validates whether the passcode authenticates the field service engineer domain for at least</para>
    //    /// <para>one product specified.</para>
    //    /// </summary>
    //    /// <param name="admin">- #CzmService instance</param>
    //    /// <param name="today">- Current calendar date in seconds since UTC 01-JAN-1970 00:00:00</param>
    //    /// <param name="user">- Service username [UTF16]</param>
    //    /// <param name="prod">- Product codes to check</param>
    //    /// <param name="pass">- Passcode</param>
    //    /// <remarks>
    //    /// <para>Authentication is granted for the single calendar dayonly.</para>
    //    /// <para>#ENIGMA_NOERROR if validation succeeded for at least one product</para>
    //    /// <para>code inand service engineer</para>
    //    /// </remarks>
    //    public static global::EnigmaWrapper.CzmError CzmEnigmaServiceValidateOnedayPasscode(global::EnigmaWrapper.CzmService admin, long today, IntPtr user, ulong userLen, string[] prod, ulong prodCnt, string pass)
    //    {
    //        var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
    //        var __ret = Internal.CzmEnigmaServiceValidateOnedayPasscode(__arg0, today, user, userLen, prod, prodCnt, pass);
    //        return __ret;
    //    }

    //    /// <summary>
    //    /// <para>Validates whether the passcode stored in a keyfile authenticates the field service</para>
    //    /// <para>engineer domain for at least one product specified.</para>
    //    /// </summary>
    //    /// <param name="admin">- #CzmService instance</param>
    //    /// <param name="today">- Current calendar date in seconds since UTC 01-JAN-1970 00:00:00</param>
    //    /// <param name="user">- Service username [UTF16]</param>
    //    /// <param name="prod">- Product codes to check</param>
    //    /// <param name="root">- UTF16-encoded path to file storage loading the keyfile from</param>
    //    /// <remarks>
    //    /// <para>Authentication is granted for the single calendar dayonly.</para>
    //    /// <para>#ENIGMA_NOERROR if validation succeeded for at least one product</para>
    //    /// <para>code inand service engineer</para>
    //    /// </remarks>
    //    public static global::EnigmaWrapper.CzmError CzmEnigmaServiceValidateOnedayPasscodeFromFile(global::EnigmaWrapper.CzmService admin, long today, IntPtr user, ulong userLen, string[] prod, ulong prodCnt, IntPtr root, ulong rootLen)
    //    {
    //        var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
    //        var __ret = Internal.CzmEnigmaServiceValidateOnedayPasscodeFromFile(__arg0, today, user, userLen, prod, prodCnt, root, rootLen);
    //        return __ret;
    //    }

    //    /// <summary>
    //    /// <para>Validates whether the passcode stored in a keyfile authenticates the field service</para>
    //    /// <para>engineer domain for at least one product specified.</para>
    //    /// </summary>
    //    /// <param name="admin">- #CzmService instance</param>
    //    /// <param name="today">- Current calendar date in seconds since UTC 01-JAN-1970 00:00:00</param>
    //    /// <param name="prod">- Product codes to check</param>
    //    /// <param name="root">- UTF16-encoded path to file storage loading the keyfile from</param>
    //    /// <remarks>
    //    /// <para>Authentication is granted for the defined range of consecutive calendar days.</para>
    //    /// <para>#ENIGMA_NOERROR if validation succeeded for at least one product</para>
    //    /// <para>code in</para>
    //    /// </remarks>
    //    public static global::EnigmaWrapper.CzmError CzmEnigmaServiceValidateMasterPasscodeFromFile(global::EnigmaWrapper.CzmService admin, long today, string[] prod, ulong prodCnt, IntPtr root, ulong rootLen)
    //    {
    //        var __arg0 = admin is null ? IntPtr.Zero : admin.Instance;
    //        var __ret = Internal.CzmEnigmaServiceValidateMasterPasscodeFromFile(__arg0, today, prod, prodCnt, root, rootLen);
    //        return __ret;
    //    }

    //    public global::EnigmaWrapper.CzmServiceResult Result
    //    {
    //        get
    //        {
    //            return global::EnigmaWrapper.CzmServiceResult.CreateInstance(new IntPtr(&((Internal*)Instance)->result));
    //        }

    //        set
    //        {
    //            if (ReferenceEquals(value, null))
    //                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
    //            ((Internal*)Instance)->result = *(global::EnigmaWrapper.CzmServiceResult.Internal*)value.Instance;
    //        }
    //    }
    //}

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError(IntPtr self, global::EnigmaWrapper.CzmError result);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError_long(IntPtr self, global::EnigmaWrapper.CzmError result, long creation);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError_long_long(IntPtr self, global::EnigmaWrapper.CzmError result, long creation, long expiration);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public unsafe delegate void Action_IntPtr_EnigmaWrapper_CzmError_IntPtr_ulong_long_long(IntPtr self, global::EnigmaWrapper.CzmError result, IntPtr user, ulong userLen, long creation, long expiration);

        public class Response
        {
            public  void Action_IntPtr_EnigmaWrapper_CzmError(IntPtr self, global::EnigmaWrapper.CzmError result)
            {

            }

            public  void Action_IntPtr_EnigmaWrapper_CzmError_long(IntPtr self, global::EnigmaWrapper.CzmError result, long creation)
            {

            }

            public  void Action_IntPtr_EnigmaWrapper_CzmError_long_long(IntPtr self, global::EnigmaWrapper.CzmError result, long creation, long expiration)
            {

            }

            public  void Action_IntPtr_EnigmaWrapper_CzmError_IntPtr_ulong_long_long(IntPtr self, global::EnigmaWrapper.CzmError result, IntPtr user, ulong userLen, long creation, long expiration)
            {

            }
        }
    }
}
